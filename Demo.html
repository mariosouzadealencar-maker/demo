<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EvoluÃ§Ã£o Humana â€“ Dificuldade</title>
<style>
html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#000;font-family:sans-serif;}
canvas{display:block;}
#hud{
  position:absolute;left:12px;top:12px;
  background:rgba(0,0,0,0.45);color:#fff;padding:10px 14px;
  border-radius:10px;backdrop-filter:blur(4px);
}
#xpbar{width:220px;height:12px;background:#333;border-radius:6px;overflow:hidden;margin-top:6px;}
#xpfill{height:100%;width:0%;background:linear-gradient(90deg,#86efac,#16a34a);transition:width 0.3s;}
#notif{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.5);color:#fff;padding:10px;border-radius:8px;display:none;}
</style>
</head>
<body>
<div id="hud">
  <div><b>ðŸŒ¿ Fase:</b> <span id="fase">Carregando...</span></div>
  <div><b>XP:</b> <span id="xptext">0</span> / <span id="xpmax">0</span></div>
  <div id="xpbar"><div id="xpfill"></div></div>
</div>
<div id="notif">Evoluiu!</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
let scene,camera,renderer,clock;
let player,velocity=new THREE.Vector3(),directionVec=new THREE.Vector3();
let orbs=[],enemies=[];
let keys={};
let xp=0,nextXP=20,currentPhase=0;
let dirLight;

const phases=[
  {geometry:new THREE.BoxGeometry(1,2,1),color:0x8B4513,name:"Primitivo",enemyCount:2,speed:0.02},
  {geometry:new THREE.CylinderGeometry(0.6,0.6,2,16),color:0x556B2F,name:"IntermediÃ¡rio",enemyCount:4,speed:0.03},
  {geometry:new THREE.SphereGeometry(1,16,16),color:0x1E90FF,name:"AvanÃ§ado",enemyCount:6,speed:0.045}
];

const faseEl=document.getElementById("fase");
const xptextEl=document.getElementById("xptext");
const xpmaxEl=document.getElementById("xpmax");
const xpfillEl=document.getElementById("xpfill");
const notifEl=document.getElementById("notif");

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x87ceeb);
  camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(0,3,8);
  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.shadowMap.enabled=true;
  document.body.appendChild(renderer.domElement);
  clock=new THREE.Clock();

  // Luz e chÃ£o
  const hemi=new THREE.HemisphereLight(0x87ceeb,0x228b22,0.8); scene.add(hemi);
  dirLight=new THREE.DirectionalLight(0xffffff,1); dirLight.position.set(5,10,5); dirLight.castShadow=true; scene.add(dirLight);
  const ground=new THREE.Mesh(new THREE.PlaneGeometry(200,200),new THREE.MeshPhongMaterial({color:0x228b22}));
  ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);

  loadPhase(currentPhase);
  spawnOrbs(12);
  window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});
  document.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
  document.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);
}

function loadPhase(idx){
  if(player) scene.remove(player);
  enemies.forEach(e=>scene.remove(e)); enemies=[];
  const ph=phases[idx];
  const mat=new THREE.MeshStandardMaterial({color:ph.color});
  player=new THREE.Mesh(ph.geometry,mat);
  player.castShadow=true; player.position.set(0,1,0);
  scene.add(player);
  spawnEnemies(ph.enemyCount);
  faseEl.textContent=ph.name; xpmaxEl.textContent=nextXP;
}

function spawnOrbs(n){
  for(let i=0;i<n;i++){
    const orb=new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8),
      new THREE.MeshStandardMaterial({color:0xffff00,emissive:0xffd700}));
    orb.position.set((Math.random()-0.5)*60,0.3,(Math.random()-0.5)*60);
    scene.add(orb); orbs.push(orb);
  }
}

function spawnEnemies(n){
  const ph=phases[currentPhase];
  for(let i=0;i<n;i++){
    const enemy=new THREE.Mesh(
      new THREE.SphereGeometry(0.5,12,12),
      new THREE.MeshStandardMaterial({color:0xff0000,emissive:0x550000})
    );
    enemy.position.set((Math.random()-0.5)*40,0.5,(Math.random()-0.5)*40);
    enemy.castShadow=true;
    enemy.userData.speed=ph.speed+Math.random()*0.01;
    scene.add(enemy); enemies.push(enemy);
  }
}

function gainXP(v){xp+=v;if(xp<0)xp=0;
  if(xp>=nextXP && currentPhase<phases.length-1){
    xp=0; nextXP*=2; currentPhase++;
    loadPhase(currentPhase);
    notifEl.style.display='block';
    setTimeout(()=>notifEl.style.display='none',1000);
  }
  xptextEl.textContent=xp.toFixed(0);
  xpfillEl.style.width=(xp/nextXP*100)+'%';
}

function flashPlayer(){
  const old=player.material.color.getHex();
  player.material.color.set(0xffffff);
  setTimeout(()=>player.material.color.set(old),150);
}

function animate(){
  requestAnimationFrame(animate);
  const delta=clock.getDelta();
  const moveSpeed=0.12;

  // Movimento
  directionVec.set(0,0,0);
  if(keys['w']||keys['arrowup']) directionVec.z-=1;
  if(keys['s']||keys['arrowdown']) directionVec.z+=1;
  if(keys['a']||keys['arrowleft']) directionVec.x-=1;
  if(keys['d']||keys['arrowright']) directionVec.x+=1;
  if(directionVec.length()>0){
    directionVec.normalize();
    player.position.addScaledVector(directionVec,moveSpeed);
    player.rotation.y=Math.atan2(directionVec.x,directionVec.z);
    gainXP(0.02);
  }

  // Coleta orbes
  for(let i=orbs.length-1;i>=0;i--){
    const orb=orbs[i];
    orb.rotation.y+=0.02;
    if(orb.position.distanceTo(player.position)<1){
      scene.remove(orb); orbs.splice(i,1); gainXP(5);
    }
  }

  // Inimigos
  enemies.forEach(enemy=>{
    const dir=player.position.clone().sub(enemy.position);
    const dist=dir.length();
    if(dist>0.1) dir.normalize();
    enemy.position.addScaledVector(dir,enemy.userData.speed);
    enemy.lookAt(player.position);
    if(dist<1.2){
      gainXP(-5);
      flashPlayer();
      enemy.position.x+=(Math.random()-0.5)*4;
      enemy.position.z+=(Math.random()-0.5)*4;
    }
  });

  // CÃ¢mera
  const target=player.position.clone().add(new THREE.Vector3(0,3,-6));
  camera.position.lerp(target,0.1);
  camera.lookAt(player.position);

  renderer.render(scene,camera);
}

init();
animate();
</script>
</body>
</html>
